/*
2579 계단 오르기

계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. <그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.''

계단 오르는 데는 다음과 같은 규칙이 있다.

계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.

점화식 구하는 방법이 잘못되었던 문제
어떻게 이렇게 생각하지??라는 생각이 들었다.
1이 두번 이상 반복된 경우엔 0을 반환하도록 하는 방식으로 처음 풀었는데 예외의 경우가 있었다.
논리적으로 잘못된 부분을 해결하면 해당 방식으로도 해결할 수 있을 것 같은데 그 부분을 찾지 못했다.

풀이 참고 : https://kosaf04pyh.tistory.com/234
문제 풀이 : https://maybemine.tistory.com/entry/dp-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EB%8F%99%EC%A0%84-9084-%EC%99%B8
*/
#include <iostream>
#include <algorithm>
using namespace std;

int N;
int score[301] = { 0, };
int dp[301] = { 0, };

int main() {
	cin >> N;
	for (int i = 1; i <= N; i++)
		cin >> score[i];
	dp[1] = score[1]; dp[2] = score[1] + score[2];
	for (int i = 3; i <= N; i++)
		dp[i] = max(dp[i - 2] + score[i], dp[i - 3] + score[i - 1] + score[i]);
	cout << dp[N];
	return 0;
}