/*
2698 인접한 비트의 개수

# https://www.acmicpc.net/problem/2698

0과 1로 이루어진 수열 S가 있다. S의 첫 수는 s1이고, 마지막 수는 sn이다. S의 인접한 비트의 개수는 다음과 같이 구할 수 있다.
s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn

위의 식을 이용하면 수열 S에서 인접한 1의 개수를 구할 수 있다. 예를들어, 011101101의 인접한 비트의 개수는 3이 되고, 111101101은 4, 010101010은 0이 된다.
수열 S의 크기 n과 k가 주어졌을 때, 인접한 비트의 개수가 k인 수열 S의 개수를 구하는 프로그램을 작성하시오.

예를 들어, n이 5이고, k가 2이면, 수열 S가 될 수 있는 수열은 다음과 같이 6가지가 있다.
11100, 01110, 00111, 10111, 11101, 11011

너무나 dp스러운 문제에다가 조건이 딱딱 떨어져 표로 만들어 작성해보고 규칙을 찾아보았다.
이전 n의 양옆의 수의 합인 것 같았지만 이 경우엔 k = 1일때 계산이 불가능했다.

이를 해결하고 dp식으로 푸는 방식은 3차원 배열을 이용하고 이 규칙은 각 끝이 0인지 1인지에 따라 다르다는 점이었다.
3차원 배열을 사용한 dp 해결방식을 생각하지 못했고 이렇게 하면 두분기로 나누어 각각의 합을 더할 수 있는 풀이 방식이라는 것을 이번 문제를 통해 알게되었다.


풀이 참고
https://gusdnr69.tistory.com/196
*/
#include <iostream>
using namespace std;

int T, N, K;
int memo[101][101][2] = { 0, };

int main() {
	memo[1][0][0] = 1;
	memo[1][0][1] = 1;
	for (int i = 2; i < 101; i++)
	{
		for (int j = 0; j < 101; j++)
		{
			memo[i][j][0] = memo[i - 1][j][0] + memo[i - 1][j][1];
			memo[i][j][1] = memo[i - 1][j][0] + memo[i - 1][j - 1][1];
		}
	}
	cin >> T;
	for (int i = 0; i < T; i++)
	{
		cin >> N >> K;
		cout << memo[N][K][0] + memo[N][K][1] << endl;
	}
	return 0;
}