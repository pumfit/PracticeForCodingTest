
/*
1449 수리공 항승
https://www.acmicpc.net/problem/1449

항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.
파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.
항승이는 길이가 L인 테이프를 무한개 가지고 있다.

항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.
물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오.
테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.

테이프를 붙이는 건 간격이 포인트이다. 위치를 배열로 받고 정렬한 후 간격을 더해 간격이 테이프 크기와 같거나 커진 경우 붙이게 했다.
해당 경우가 아닌 경우라도 마지막이라면 테이프를 붙이도록 하게 해 테이프의 개수를 세었다.

오랫만에 한번에 풀었던 문제라 마음이 편안했다.
다른 풀이 방식도 비슷한 로직으로 풀이하는 경우가 많았고 현재 상황을 탐색하며 정답을 더해가는 그리디방식 풀이였다.

*/
#include <iostream>
#include <algorithm>
using namespace std;

int arr[1001];

int main() {
	int N, L;
	int answer = 0;
	cin >> N >> L;
	for (int i = 0; i < N; i++)
	{
		cin >> arr[i];
	}
	//내림 차순으로 정렬 4 3 2 1
	sort(arr, arr + N, greater<int>());
	int sum = 0;

	// 배열을 순회
	for (int i = 0; i < N; i++)
	{
		// 두 위치간의 거리를 구하여 합한다.
		sum += arr[i] - arr[i + 1];
		if (sum >= L) // 합 한 값이 테이프 길이를 넘어가는 순간 테이프를 붙인다.
		{
			answer++;
			sum = 0;
		}
		else
		{
			//배열의 마지막인 경우
			if (N - 1 == i)
			{
				answer++;
			}
		}
	}
	cout << answer;
	return 0;
}