/*
1769 3의배수

문제 1. "양의 정수 X는 3의 배수인가?"

이 문제를 아래와 같이 변환하는데, X의 각 자리의 수를 단순히 더한 수 Y를 만든다.
예를 들어 X가 1107이었다면, Y는 1+1+0+7=9가 된다. 그리고 Y에 대해서, 아래와 같은 문제를 생각한다.

문제 2. "Y는 3의 배수인가?"

위의 문제 1의 답은 아래의 문제 2의 대답과 일치한다. 위의 예의 경우, 
Y=9는 3의 배수이므로 X=1107 역시 3의 배수가 되는 것이다. 214는 각 자리수의 합 2+1+4=7이 3의 배수가 아니므로 3의 배수가 아니다.

문제 1을 풀고 싶으면 문제 2로 변환을 해서 문제 2의 답을 문제 1의 답으로 삼으면 된다. 일반적으로 Y는 X보다 크기가 작으므로, 문제 2가 더 쉬운 문제가 된다.
당신이 알고 있는 3의 배수는 한 자리 수밖에 없다고 가정하자. 즉, 문제 변환의 과정을 여러 번 거치다 보면 Y가 한 자리 수가 되는 순간이 있게 되는데, 그렇게 될 때까지 문제 변환을 반복한다는 뜻이다. 변환 후의 Y가 3, 6, 9 중 하나이면 원래의 수 X는 3의 배수이고, Y가 1, 2, 4, 5, 7, 8 중 하나이면 원래의 수 X는 3의 배수가 아니다.

큰 수 X가 주어졌을 때, 앞에서 설명한 문제 변환의 과정을 몇 번 거쳐야 Y가 한 자리 수가 되어, X가 3의 배수인지 아닌지를 알 수 있게 될지를 구하는 프로그램을 작성하시오.

 1,000,000자리라서 string으로 받아야하는걸 int형으로 받고 있어서 두번 틀렸다. int로 구현한것을 string으로 바꾸는 작업을 진행했고
 진행하면서 45번라인 N.length()>1 가 원래 N>=10이였는데 바꾸는 과정에서 >=로 바꿔서 오버플로우가 한번 났었다. 주의하고 제발 문제를 잘 읽자
 1,000,000자리라고 해도 각 자리수를 더하면 int형 범위를 넘지 않는 것 같다. 혹시 또 틀리면 29번 int형을 long으로 바꾸려고 했다. 
*/
#include<iostream>
#include<string>
using namespace std;

string getSum(string n)
{
	int sum = 0;
	for (int i = 0; i < n.length(); i++)
	{
		sum += n[i]-'0';
	}
	return to_string(sum);
}

int main()
{
	string N;
	string ans = "";
	int cnt = 0;

	cin >> N;
	
	while (N.length() > 1)
	{
		N = getSum(N);
		cnt++;
	}

	ans = stoi(N) % 3 == 0 ? "YES" : "NO";

	cout << cnt<<endl;
	cout << ans;

}